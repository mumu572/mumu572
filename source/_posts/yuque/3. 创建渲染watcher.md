---
title: 3. 创建渲染watcher
urlname: kz842k
date: '2021-01-16 17:52:18 +0800'
tags: []
categories: []
---

data 中的每个属性都会被观测，换句话说，每个属性都是被观察者，当它发生变化就会通知视图更新。一个属性有可能有多个观察者 watcher。

## 初始化渲染 Watcher

```javascript
import { mountComponent } from "./lifecycle";
Vue.prototype.$mount = function (el) {
  const vm = this;
  const options = vm.$options;
  el = document.querySelector(el);

  // 如果没有render方法
  if (!options.render) {
    let template = options.template;
    // 如果没有模板但是有el
    if (!template && el) {
      template = el.outerHTML;
    }

    const render = compileToFunctions(template);
    options.render = render;
  }
  mountComponent(vm, el);
};
```

### lifecycle.js

```javascript
export function lifecycleMixin() {
  Vue.prototype._update = function (vnode) {};
}
export function mountComponent(vm, el) {
  vm.$el = el;
  let updateComponent = () => {
    // 将虚拟节点 渲染到页面上
    vm._update(vm._render());
  };
  new Watcher(vm, updateComponent, () => {}, true);
}
```

### render.js

```javascript
export function renderMixin(Vue) {
  Vue.prototype._render = function () {};
}
```

### watcher.js

```javascript
let id = 0;
class Watcher {
  constructor(vm, exprOrFn, cb, options) {
    this.vm = vm;
    this.exprOrFn = exprOrFn;
    if (typeof exprOrFn == "function") {
      this.getter = exprOrFn;
    }
    this.cb = cb;
    this.options = options;
    this.id = id++;
    this.get();
  }
  get() {
    this.getter();
  }
}

export default Watcher;
```

先调用`_render`方法生成虚拟`dom`,通过`_update`方法将虚拟`dom`创建成真实的`dom`

## 生成虚拟`dom`

```javascript
import { createTextNode, createElement } from "./vdom/create-element";
export function renderMixin(Vue) {
  Vue.prototype._v = function (text) {
    // 创建文本
    return createTextNode(text);
  };
  Vue.prototype._c = function () {
    // 创建元素
    return createElement(...arguments);
  };
  Vue.prototype._s = function (val) {
    return val == null
      ? ""
      : typeof val === "object"
      ? JSON.stringify(val)
      : val;
  };
  Vue.prototype._render = function () {
    const vm = this;
    const { render } = vm.$options;
    let vnode = render.call(vm);
    return vnode;
  };
}
```

### 创建虚拟节点

```javascript
export function createTextNode(text) {
  return vnode(undefined, undefined, undefined, undefined, text);
}
export function createElement(tag, data = {}, ...children) {
  let key = data.key;
  if (key) {
    delete data.key;
  }
  return vnode(tag, data, key, children);
}
function vnode(tag, data, key, children, text) {
  return {
    tag,
    data,
    key,
    children,
    text,
  };
}
```

## 生成真实`DOM`元素

将虚拟节点渲染成真实节点

```javascript
import {patch} './observer/patch'
export function lifecycleMixin(Vue){
    Vue.prototype._update = function (vnode) {
        const vm = this;
        vm.$el = patch(vm.$el,vnode);
    }
}
```

```javascript
export function patch(oldVnode, vnode) {
  const isRealElement = oldVnode.nodeType;
  if (isRealElement) {
    const oldElm = oldVnode;
    const parentElm = oldElm.parentNode;

    let el = createElm(vnode);
    parentElm.insertBefore(el, oldElm.nextSibling);
    parentElm.removeChild(oldVnode);
    return el;
  }
}
function createElm(vnode) {
  let { tag, children, key, data, text } = vnode;
  if (typeof tag === "string") {
    vnode.el = document.createElement(tag);
    updateProperties(vnode);
    children.forEach((child) => {
      return vnode.el.appendChild(createElm(child));
    });
  } else {
    vnode.el = document.createTextNode(text);
  }
  return vnode.el;
}
function updateProperties(vnode) {
  let newProps = vnode.data || {}; // 获取当前老节点中的属性
  let el = vnode.el; // 当前的真实节点
  for (let key in newProps) {
    if (key === "style") {
      for (let styleName in newProps.style) {
        el.style[styleName] = newProps.style[styleName];
      }
    } else if (key === "class") {
      el.className = newProps.class;
    } else {
      // 给这个元素添加属性 值就是对应的值
      el.setAttribute(key, newProps[key]);
    }
  }
}
```
