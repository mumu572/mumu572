---
title: 5. 依赖收集
urlname: kimq12
date: '2021-01-18 14:14:42 +0800'
tags: []
categories: []
---

每个属性都要有一个`dep`,每个`dep`中存放着`watcher`,同一个`watcher`会被多个`dep`所记录。

## 在渲染时存储 watcher

```javascript
class Watcher {
  // ...
  get() {
    pushTarget(this);
    this.getter();
    popTarget();
  }
}
```

```javascript
let id = 0;
class Dep {
  constructor() {
    this.id = id++;
  }
}
let stack = [];
export function pushTarget(watcher) {
  Dep.target = watcher;
  stack.push(watcher);
}
export function popTarget() {
  stack.pop();
  Dep.target = stack[stack.length - 1];
}
export default Dep;
```

### 对象依赖收集

```javascript
let dep = new Dep();
Object.defineProperty(data, key, {
  get() {
    if (Dep.target) {
      // 如果取值时有watcher
      dep.depend(); // 让watcher保存dep，并且让dep 保存watcher
    }
    return value;
  },
  set(newValue) {
    if (newValue == value) return;
    observe(newValue);
    value = newValue;
    dep.notify(); // 通知渲染watcher去更新
  },
});
```

### **Dep 实现**

```javascript
class Dep {
  constructor() {
    this.id = id++;
    this.subs = [];
  }
  depend() {
    if (Dep.target) {
      Dep.target.addDep(this); // 让watcher,去存放dep
    }
  }
  notify() {
    this.subs.forEach((watcher) => watcher.update());
  }
  addSub(watcher) {
    this.subs.push(watcher);
  }
}
```

### **watcher**

```javascript
constructor(){
	this.deps = [];
	this.depsId = new Set();
}
addDep(dep){
    let id = dep.id;
    if(!this.depsId.has(id)){
        this.depsId.add(id);
        this.deps.push(dep);
        dep.addSub(this);
    }
}
update(){
    this.get();
}
```

## 数组的依赖收集

```javascript
this.dep = new Dep(); // 专门为数组设计的
if (Array.isArray(value)) {
  value.__proto__ = arrayMethods;
  this.observeArray(value);
} else {
  this.walk(value);
}

function defineReactive(data, key, value) {
  let childOb = observe(value);
  let dep = new Dep();
  Object.defineProperty(data, key, {
    get() {
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend(); // 收集数组依赖
        }
      }
      return value;
    },
    set(newValue) {
      if (newValue == value) return;
      observe(newValue);
      value = newValue;
      dep.notify();
    },
  });
}

arrayMethods[method] = function (...args) {
  // ...
  ob.dep.notify();
  return result;
};
```

### **递归收集数组依赖**

```javascript
if (Dep.target) {
  dep.depend();
  if (childOb) {
    childOb.dep.depend(); // 收集数组依赖
    if (Array.isArray(value)) {
      // 如果内部还是数组
      dependArray(value); // 不停的进行依赖收集
    }
  }
}
function dependArray(value) {
  for (let i = 0; i < value.length; i++) {
    let current = value[i];
    current.__ob__ && current.__ob__.dep.depend();
    if (Array.isArray(current)) {
      dependArray(current);
    }
  }
}
```
