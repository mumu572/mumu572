---
title: 思维导图
urlname: zf7oap
date: '2020-11-29 18:45:17 +0800'
tags: []
categories: []
---

{"format":"lakemind","type":"Mind","version":"1.0","diagramData":{"head":{"version":"2.0.0"},"body":[{"id":"init","type":"mindmap","html":"Node","x":-726.6939260200423,"y":-540.0919323843502,"zIndex":28,"children":[{"html":"node 是一个可以将 js 运行在服务端的运行时。","layout":{"quadrant":1},"treeEdge":{"stroke":"#A287E1"},"id":"623c3fa5-4179-4e63-98d1-7d6475439ded","children":[],"zIndex":0},{"html":"Buffer","layout":{"quadrant":1},"treeEdge":{"stroke":"#E48484"},"id":"0602558b-5c7a-4da5-a6bc-1c58feed2041","children":[{"html":"存储的是二进制","id":"311781e9-af86-46e5-8953-b99ccc172c5d","children":[],"zIndex":2},{"html":"原型方法","id":"ac9845d9-7e0b-4ce7-91ea-6b85756e5552","children":[{"html":"copy","id":"7bba005a-2392-4895-837a-1e3c591a5478","children":[],"zIndex":24},{"html":"indexOf","id":"835a3451-1d6f-4439-a033-a1a6f2353822","children":[{"html":"和字符串中的 indexOf 使用方法相同，返回的是字节的索引","id":"63063e17-c99a-43fa-af75-f43081fd5f76","children":[],"zIndex":26}],"zIndex":25}],"zIndex":23},{"html":"静态方法：concat","id":"e0758b4f-73b2-4a47-aba0-95e6fb6d21e5","children":[{"html":"默认会根据要合并 buffer 的最大长度来拼接，节省内存","id":"3a18d45d-445f-4e67-9e4e-7f37ed29d8b5","children":[],"zIndex":22}],"zIndex":3}],"zIndex":1},{"html":"fs","layout":{"quadrant":1},"treeEdge":{"stroke":"#69B1E4"},"id":"f230fa72-f36d-41f4-8575-980f0e726962","children":[{"html":"<span style=\"color:rgb(105, 177, 228);\">读完之后才可以写，写完之后才可以读。</span>","id":"ca74c536-891a-4527-ac18-47042c636b17","children":[],"zIndex":5},{"html":"读取文件的时候，如果文件比较大，如果一次性把文件的内容全部读取出来，会淹没内存；我们可以用文件流的方式，一点一点的把文件读取出来。","id":"b5b15e12-bb27-4327-a140-c29c528141d8","children":[],"zIndex":16},{"html":"rwxr-xr-x => (rwx) (r-x) (r-x)","id":"3a141d2a-e36f-4578-acd6-fb6056b65249","children":[{"html":"含义(8 进制)：r:4  w:2  x:1","id":"01680acb-0286-4818-8736-dc1a9fa75e95","children":[],"zIndex":15}],"zIndex":14},{"html":"流","id":"a57279a1-11f6-40e7-8af1-c167317395f4","children":[{"html":"文件流不是流，它是基于流的。","id":"7c3f7d11-d55b-44cc-93b8-e5c0b8b352a3","children":[],"zIndex":7},{"html":"Readable 接口","id":"5b48bb1f-8533-4506-9949-523d72ece365","children":[{"html":"是 steam 模块中的一个接口，ReadStream 是基于它实现的，重写了它的\_read 方法","id":"41833656-d4aa-4add-af4c-addf92d297f4","children":[],"zIndex":18}],"zIndex":17},{"html":"可读流：ReadStream","id":"cef67b3f-b09a-4efc-b2e7-e8abee93eb9b","children":[{"html":"1.内部使用 fs.open,fs.read,发布订阅模式","id":"b051f5ef-a4f7-4e51-a9b3-431285b4595c","children":[],"zIndex":13},{"html":"2.内部基于发布订阅模式把\_read 和 open 方法解耦","id":"206270e5-a4a9-43d4-8931-7b2935660a92","children":[],"zIndex":19},{"html":"3.constructor 中默认会调用一次 open 方法，在 open 方法中会触发 emit('open')事件","id":"70071bd7-4f25-4bfe-9612-189ee15bb612","children":[],"zIndex":21},{"html":"4.在 constructor 中监听了 newListener 事件，当监听的事件是 data 时，去调用\_read 方法，如果 fd 没有内容，则会自动监听 once('open')事件，在 open 事件的回调再调用\_read 自身，下一次事件触发，就一定会拿到 fd 了，就是利用这种方式进行解耦和通信的。","id":"1e095922-7845-46ff-bd05-a59917eb0f75","children":[],"zIndex":20}],"zIndex":8},{"html":"可写流：WriteStream","id":"866b685a-c9f0-4ebc-9542-1cbe6ebc1cf9","children":[{"html":"1.第一次先直接写入文件中，之后的都临时放到内存中(存放的是栈型结构)","id":"19198069-76a9-45f8-9c74-d3e6fadbb6ed","children":[],"zIndex":10},{"html":"2.当第一次写入完毕后，会把之前存放在内存中的从栈顶取出一个，把拿到的内容再写入文件","id":"f4dc1484-9f07-4cd9-b342-f31129eacabd","children":[],"zIndex":11},{"html":"3.等待写入完成后，继续从之前存放的从栈顶取出一个，循环写入，直到栈为空为止","id":"9c5c2f94-013b-4484-92bf-a4dac3a084b7","children":[],"zIndex":12}],"zIndex":9}],"zIndex":6}],"zIndex":4},{"html":"链表","layout":{"quadrant":1},"treeEdge":{"stroke":"#DE81C6"},"id":"9d285499-e7c6-48a0-bd93-bf985b20082a","children":[],"zIndex":27}],"border":{"shape":"rect"}}]},"viewportSetting":{"zoom":1.05,"tlCanvasPoint":[-969.0034325009301,-1479.258585611979,1],"width":1301,"height":994},"text":"Nodenode 是一个可以将 js 运行在服务端的运行时。Buffer 存储的是二进制原型方法 copyindexOf 和字符串中的 indexOf 使用方法相同，返回的是字节的索引静态方法：concat 默认会根据要合并 buffer 的最大长度来拼接，节省内存 fs 读完之后才可以写，写完之后才可以读。读取文件的时候，如果文件比较大，如果一次性把文件的内容全部读取出来，会淹没内存；我们可以用文件流的方式，一点一点的把文件读取出来。rwxr-xr-x => (rwx) (r-x) (r-x)含义(8 进制)：r:4  w:2  x:1 流文件流不是流，它是基于流的。Readable 接口是 steam 模块中的一个接口，ReadStream 是基于它实现的，重写了它的\_read 方法可读流：ReadStream1.内部使用 fs.open,fs.read,发布订阅模式 2.内部基于发布订阅模式把\_read 和 open 方法解耦 3.constructor 中默认会调用一次 open 方法，在 open 方法中会触发 emit('open')事件 4.在 constructor 中监听了 newListener 事件，当监听的事件是 data 时，去调用\_read 方法，如果 fd 没有内容，则会自动监听 once('open')事件，在 open 事件的回调再调用\_read 自身，下一次事件触发，就一定会拿到 fd 了，就是利用这种方式进行解耦和通信的。可写流：WriteStream1.第一次先直接写入文件中，之后的都临时放到内存中(存放的是栈型结构)2.当第一次写入完毕后，会把之前存放在内存中的从栈顶取出一个，把拿到的内容再写入文件 3.等待写入完成后，继续从之前存放的从栈顶取出一个，循环写入，直到栈为空为止链表"}
