---
title: '1. 响应式原理: 数据劫持和数据代理'
urlname: apqad6
date: '2021-01-14 11:14:41 +0800'
tags: []
categories: []
---

核心通过 Object.defineProperty 劫持数据，但是由于它无法观测数组，所以 Vue 重写了数组的 7 个方法，对新增的项重新进行观测。
入口开始：

```javascript
import { initMixin } from "./init";

function Vue(options) {
  this._init(options);
}
initMixin(Vue); // 给原型上新增_init方法
export default Vue;
```

给 Vue 原型上增加\_init 方法，init 方法中初始化 Vue 状态。

```javascript
import { initState } from "./state";
export function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    const vm = this;
    vm.$options = options;
    // 初始化状态
    initState(vm);
  };
}
```

new Vue 传入 options，然后根据 options 的不同属性进行初始化操作。

```javascript
export function initState(vm) {
  const opts = vm.$options;
  if (opts.props) {
    initProps(vm);
  }
  if (opts.methods) {
    initMethod(vm);
  }
  if (opts.data) {
    // 初始化data
    initData(vm);
  }
  if (opts.computed) {
    initComputed(vm);
  }
  if (opts.watch) {
    initWatch(vm);
  }
}
function initProps() {}
function initMethod() {}
function initData() {}
function initComputed() {}
function initWatch() {}
```

## 初始化数据

如果用户传入的 data 是一个函数，执行这个函数并将 this 指向改为 vm。
并观测 data 对象。

> data 是一个函数是因为 return 的是一个全新的对象，防止多次引用造成的变量污染。

```javascript
import { observe } from "./observer/index.js";
function initData(vm) {
  let data = vm.$options.data;
  data = vm._data = typeof data === "function" ? data.call(vm) : data;
  observe(data);
}
```

## 递归属性劫持

如果 data 是一个对象则会通过 Observer 创建一个实例，在 Observer 类中对 data 中的每一个属性进行劫持，如果 data 属性又是对象，则继续进行观测。

```javascript
class Observer {
  // 观测值
  constructor(value) {
    this.walk(value);
  }
  walk(data) {
    // 让对象上的所有属性依次进行观测
    let keys = Object.keys(data);
    for (let i = 0; i < keys.length; i++) {
      let key = keys[i];
      let value = data[key];
      defineReactive(data, key, value);
    }
  }
}
function defineReactive(data, key, value) {
  observe(value);
  Object.defineProperty(data, key, {
    get() {
      return value;
    },
    set(newValue) {
      if (newValue == value) return;
      observe(newValue);
      value = newValue;
    },
  });
}
export function observe(data) {
  if (typeof data !== "object" || data == null) {
    return;
  }
  return new Observer(data);
}
```

## 数组方法劫持

由于 Object.defineProperty 无法对数组进行观测，所以会对数组进行特殊处理。

1. 遍历数组的每一项，对每一项都进行观测
1. Vue 重写了会对数组本身改变的 7 个 API：push、pop、shift、unshift、sort、reverse、splice，并且拦截传入的新数据，继续观测。
   > 给所有响应式对象增加**ob**属性，值是当前实例，它可以作为一个标识，也可以在其他地方获取到响应式 Observer 实例上的方法。

```diff
import {arrayMethods} from './array';
class Observer { // 观测值
    constructor(value){
+      	Object.defineProperty(value,'__ob__',{
+           enumerable:false,
+           configurable:false,
+           value:this
+       });
+       if(Array.isArray(value)){
+           value.__proto__ = arrayMethods; // 重写数组原型方法
+           this.observeArray(value);
+       }else{
           	this.walk(value);
+       }
    }
+   observeArray(value){
+       for(let i = 0 ; i < value.length ;i ++){
+           observe(value[i]);
+       }
+   }
    // ...
}
```

```javascript
let oldArrayProtoMethods = Array.prototype;
export let arrayMethods = Object.create(oldArrayProtoMethods);
let methods = ["push", "pop", "shift", "unshift", "reverse", "sort", "splice"];
methods.forEach((method) => {
  arrayMethods[method] = function (...args) {
    const result = oldArrayProtoMethods[method].apply(this, args);
    const ob = this.__ob__;
    let inserted;
    switch (method) {
      case "push":
      case "unshift":
        inserted = args;
        break;
      case "splice":
        inserted = args.slice(2);
      default:
        break;
    }
    if (inserted) ob.observeArray(inserted); // 对新增的每一项进行观测
    return result;
  };
});
```

## 数据代理

通过 this.xx 可以直接访问到 this.\_data.xxx 的值。

```javascript
function proxy(vm, source, key) {
  Object.defineProperty(vm, key, {
    get() {
      return vm[source][key];
    },
    set(newValue) {
      vm[source][key] = newValue;
    },
  });
}
function initData(vm) {
  let data = vm.$options.data;
  data = vm._data = typeof data === "function" ? data.call(vm) : data;
  for (let key in data) {
    // 将_data上的属性全部代理给vm实例
    proxy(vm, "_data", key);
  }
  observe(data);
}
```
