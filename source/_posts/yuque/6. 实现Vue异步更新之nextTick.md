---
title: 6. 实现Vue异步更新之nextTick
urlname: qbspcs
date: '2021-01-18 14:21:46 +0800'
tags: []
categories: []
---

## 实现队列机制

```javascript
update(){
    queueWatcher(this);
}
```

### **scheduler**

```javascript
import { nextTick } from "../util/next-tick";
let has = {};
let queue = [];

function flushSchedulerQueue() {
  for (let i = 0; i < queue.length; i++) {
    let watcher = queue[i];
    watcher.run();
  }
  queue = [];
  has = {};
}
let pending = false;
export function queueWatcher(watcher) {
  const id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    queue.push(watcher);
    if (!pending) {
      nextTick(flushSchedulerQueue);
      pending = true;
    }
  }
}
```

## nextTick 实现原理

**util/next-tick.js**

```javascript
let callbacks = [];
function flushCallbacks() {
  callbacks.forEach((cb) => cb());
}
let timerFunc;
if (Promise) {
  // then方法是异步的
  timerFunc = () => {
    Promise.resolve().then(flushCallbacks);
  };
} else if (MutationObserver) {
  // MutationObserver 也是一个异步方法
  let observe = new MutationObserver(flushCallbacks); // H5的api
  let textNode = document.createTextNode(1);
  observe.observe(textNode, {
    characterData: true,
  });
  timerFunc = () => {
    textNode.textContent = 2;
  };
} else if (setImmediate) {
  timerFunc = () => {
    setImmediate(flushCallbacks);
  };
} else {
  timerFunc = () => {
    setTimeout(flushCallbacks, 0);
  };
}
export function nextTick(cb) {
  callbacks.push(cb);
  timerFunc();
}
```
